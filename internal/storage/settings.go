package storage

import (
	"encoding/json"
	"os"
	"path/filepath"
)

// Settings stores user preferences including last played game configuration.
type Settings struct {
	LastPlayedModeID     string `json:"last_played_mode_id,omitempty"`
	LastPlayedDifficulty string `json:"last_played_difficulty,omitempty"`
	LastPlayedDurationMs int64  `json:"last_played_duration_ms,omitempty"`
}

// HasLastPlayed returns true if settings contain valid last played data.
func (s *Settings) HasLastPlayed() bool {
	return s.LastPlayedModeID != "" && s.LastPlayedDifficulty != "" && s.LastPlayedDurationMs > 0
}

// LoadSettings reads settings from the JSON file.
// Returns empty settings if the file doesn't exist or is invalid.
func LoadSettings() (*Settings, error) {
	path, err := SettingsPath()
	if err != nil {
		return nil, err
	}

	data, err := os.ReadFile(path)
	if err != nil {
		if os.IsNotExist(err) {
			return &Settings{}, nil
		}
		return nil, err
	}

	var settings Settings
	if err := json.Unmarshal(data, &settings); err != nil {
		// Return empty settings on parse error. Unlike Load() in statistics.go
		// (which returns errors for critical user data), settings are non-critical
		// and can be regenerated by playing another game.
		return &Settings{}, nil
	}

	return &settings, nil
}

// SaveSettings writes settings to the JSON file using atomic write.
func SaveSettings(settings *Settings) error {
	path, err := SettingsPath()
	if err != nil {
		return err
	}

	data, err := json.MarshalIndent(settings, "", "  ")
	if err != nil {
		return err
	}

	// Write to temp file first for atomic operation.
	// Temp file is created in same directory as target to ensure rename is atomic.
	dir := filepath.Dir(path)
	tmp, err := os.CreateTemp(dir, "settings-*.tmp")
	if err != nil {
		return err
	}
	tmpPath := tmp.Name()

	// Clean up temp file on any error
	shouldCleanup := true
	defer func() {
		if shouldCleanup {
			os.Remove(tmpPath)
		}
	}()

	// Set restrictive permissions. Note: there's a brief window between CreateTemp
	// and Chmod where the file has default permissions. This is acceptable because:
	// 1. The temp file has a random name, making it hard to predict
	// 2. The window is typically < 1ms
	// 3. The data is user preferences, not credentials
	if err := tmp.Chmod(0600); err != nil {
		_ = tmp.Close()
		return err
	}

	if _, err := tmp.Write(data); err != nil {
		_ = tmp.Close()
		return err
	}

	// Sync to ensure data is flushed to disk before rename.
	// Prevents data loss on system crash or power failure.
	if err := tmp.Sync(); err != nil {
		_ = tmp.Close()
		return err
	}

	if err := tmp.Close(); err != nil {
		return err
	}

	// Atomic rename (works because temp file is in same directory as target)
	if err := os.Rename(tmpPath, path); err != nil {
		return err
	}

	shouldCleanup = false // Prevent cleanup of successfully renamed file
	return nil
}
